### 精通Linux 第二版

##### 1 linux层次

三层： 最底层是硬件 硬件之上是内核 内核是操作系统核心  内核是运行在内存中的软件  

内核向中央处理器发送指令 内核管理硬件系统  是硬件系统和应用程序之间进行通信的接口  

进程是指计算机中运行的所有程序 进程由内核统一管理 进程组成最顶层 称为用户空间  


用户进程  


linux内核： 系统调用  进程管理  内存管理  设备驱动程序

硬件： cpu  内存  硬盘  网络端口  


内核和用户进程之间最主要的区别： 内核在内核模式 Kernel mode中运行  用户进程则在用户模式 user mode中运行  

内核模式中运行的代码可以不受限的访问cpu和内存 功能强大  非常危险  那些只有内核可以访问的空间称为内核空间 kernel space  

内核的内存管理  

内核将内存划分为很多区块 并且一直维护这些区块的状态信息  

内核负责管理四个方面：

* 进程 内核决定那个进程可以使用cpu

* 内存 内核管理所有内存 为进程分配内存 管理进程间的共享内存以及空闲内存

* 设备驱动程序 作为硬件系统与进程之间的接口 内存负责操控硬件设备

* 系统调用和支持 进程通常使用系统调用和内核进行通信


进程管理  

管理涉及到：进程的启动  暂停  恢复和终止  

一个进程让出CPU使用权给另一个进程称为上下文切换 context switch  

系统是在同时运行多个进程称之为多任务执行

内核负责上下文切换  其工作原理如下：

1. cpu为每一个进程及时 到时即停止进程 并切换至内内核模式---由内核接管CPU控制权  

2. 内核记录当前cpu和内存的状态信息 这些信息在恢复被停止的进程时需要用到

3. 内核执行上一个时间段内的任务

4. 内核准备执行下一个进程  从准备就绪的进程中选择一个执行  

5. 内核将新进程准备cpu和内存  

6. 内核将新进程执行的时间段通知cpu

7. 内核将cpu切换至用户模式 将cpu控制权移交给新进程  

内核是在什么时候运行的？ 内核在上下文切换时的时间段间隙中运行的  


内存管理  

内核在上下文切换过程中管理内存  

内核要保证以下所有条件：  

* 内核需要自己的专有内存空间 其他用户进程无法访问  

* 每个用户进程有自己的专有内存空间  

* 一个进程不能访问另一个进程的专有内存空间

* 用户进程之间可以共享内存  

* 用户进程的某些内存空间可以是只读的

* 通过使用磁盘交换 系统可以使用比实际内存容量更多的内存空间

Memory Management Unit 内存管理单元 MMU
MMU使用了一种叫作虚拟内存的内存访问机制  即进程不是直接访问内存的实际物理地址  而是通过内核使得进程看起来可以使用整个系统的内存  
即进程访问内存的时候 MMU截获访问请求 然后通过内存映射表将要访问的内存地址转换为实际的物理地址  

内核需要初始化 维护和更新这个地址映射表。例如在上下文切换时 内核将内存映射表从被移出进程转给被移入进程使用  

设备驱动程序和设备管理  

1. 通常设备只能在内核模式中被访问 因为设备访问不当有可能会让系统崩溃  
2. 不同设备之间没有一个统一编程接口 设备驱动程序会尽可能为用户进程提供统一的接口  以简化开发人员的工作  

系统调用和系统支持  

系统调用 system call或syscall 为进程执行一些它们不擅长或无法完成的工作  例如 打开  读取  写文件  

fork 当进程调用fork()时 内核创建一个和该进程几乎一模一样的副本  

exec 当进程调用exec(program)时 内核启动program来替换当前的进程  

Linux中的所有的用户进程都是通过fork()来启动的 除了创建现有进程的副本外  大多数情况下你还可以使用exec()来启动新进程  

通过ls命令说明：

通过终端输入ls时 终端窗口中的shell调用fork()创一个shell的副本  
然后这个shell副本 调用exec(ls)来运行ls   

虚拟设备  

虚拟设备对于用户进程而言是物理设备 但是通过软件来实现的 因此从技术角度来说  它们并不需要存在于内核中 但是实际上它们很多都存在于内核中。  


用户空间  

内核分配给用户进程的内存空间 称为用户空间 userland 

一个进程就是内存中的一个状态 用户空间也可以指所有用户进程占用的所有内存  

用户  

linux内核支持用户这一Unix的传统概念 一个用户代表一个实体  用户有权限运行用户进程 对文件拥有所有权  
每个用户都有一个用户名 然后内核是用户ID来管理用户的 用户ID是一串数字标识  

用户机制主要权限管理  每个用户进程都有一个用户作为所有者 在一定限制条件下 用户可以终止和改变自己的进程的行为  
但对其他用户的进程无权干预  用户可以决定是否将属于自己的文件和其他的用户共享  但是root例外 

##### 2 基础命令 目录结构

1. shell /bin/sh

shell 命令行界面  是运行命令行的应用程序  命令行就是用户输入的哪些命令  

提示符格式： name@host:$path$

$后面是命令

2. cat 显示一个或多个文件 


3. cat 不指定文件名 就从linux内核提供默认标准流中获得输入数据 这时运行cat命令的终端就成为标准输入  

ctrl+d 终止当前终端的标准输入并终止命令 通常会终止一个程序

ctrl+C 终止当前进程

内核为每个进程提供一个标准输出流供进程输出数据  cat命令将数据输出到标准输出  

标准输入和标准输出 stdin stdout

4. ls 显示目录内容  

5. cp 拷贝

```
cp file1 file2 将文件1复制到文件2

cp file1 ... fileN dir 将文件们复制到指定目录
```

6. mv 重命名 移动文件

```
mv file1 file2 将文件1改名为文件2

mv file1 ... fileN dir 将文件们移动到指定目录

```

7. touch 创建文件

8. rm 删除文件

9. echo 输出


目录结构  

/ 根目录  

.. 上一层目录  

. 当前目录  

绝对路径  从根目录开始  

相对路径  不从目录开始  


10. cd 设置当前目录  

11. mkdir 创建目录  

12. rmdir 删除空目录  

13. rm -rf dir 真正目录

14. 通配符  shell中可以使用通配符来匹配文件名和目录名  

shell根据参数中的通配符来匹配文件名  shell命令中的参数替换为实际的文件名  这个过程称为展开  


* 代表任意字符和数字    

? 代表一个字符和数字  

如果不想让通配符展开 就可以用单引号 ''  

15. grep 显示文件和输入流和参数匹配的行  

```
grep root /etc/passwd
显示passwd文件中所有含有root的行

grep root /etc/*
显示etc目录下所有含有root的文件

-i 不区分大小写

-v 反转匹配 

-E 识别正则表达式

```

16. less 分屏显示 空格键 下一屏 B 上一屏 Q 退出

17. pwd 当前目录  

18. diff 查看文件间不同

```
diff -u file1 file2


```

19. file 查看文件格式信息  UTF-8 Unicode text

```
file  filename

```

20. find  在特定目录中查找文件

```
find dir -name file -print

```

在find可以使用模式匹配参数 但是必须加引号 以免shell展开

21. locate 

locate与find的区别 locate通过系统创建文件索引查找 比find快 但是新文件无能为力 因为新文件不会被系统立即索引

22. head 文件前10行 tail 最后10行 

-n 设置显示行数

head -n 5 /etc/passwd  前5行

tail -n +k 显示从k行以后所有内容

23. sort 对文件内所有行按照字母顺序快速排序 

使用参数 -n 按照数字顺序排序 那些以数字开头行

使用参数 -v 反向排序

24. passwd 更改密码

25. chsh 更改shell 

26. dot 文件

dot文件特别之处 ls只有加 -a 才显示 shell通配符不匹配dot文件 除非明确指定.*  

.* 会匹配 .当前目录 ..上级目录   可以使用正则表达式 .[^.] * 或 .??* 来排除这两个目录  

27. shell变量 

shell可以保存一些临时变量 称作shell变量  

使用等号给shell变量赋值  

```
STUFF=blash

```

用$STUFF来获得该变量的值  

28. 环境变量

环境变量不仅针对shell linux系统中所有进程都能访问环境变量  

环境变量与shell变量的区别:  

shell变量只能在当前的shell访问  

环境变量能够被shell中运行的所有进程访问  

环境变量可以export设置  

```
STUFF=blash

export STUFF
```

29. 命令路径

PATH是一个特殊的变量 PATH定义了命令路径 简称路径  

命令路径是一个系统目录列表 shell在执行一个命令的时候 会去这些目录中查找这个命令  

```
echo $PATH

```
路径之间以冒号 : 分隔

设置路径 PATH=$PATH:dir 或 PATH=dir:$PATH  

30. 特殊字符

\* 通配符  

. 当前目录  

! 逻辑非运算符 命令历史  

| 命令管道  

/ 目录分隔符 搜索命令  

\ 常量 宏  

$ 变量符号  行尾  

' 字符串常量  

` 命令替换  

" 半字符串常量  

^ 逻辑非运算符  行头  

~ 逻辑非运算符 home目录快捷方式  

\# 注释 预处理  替换  

[] 范围  

{} 声明块  范围  

_ 空格的简易替代  

31. 命令行编辑 


ctrl+b 左移光标  

ctrl+f 右移光标  



ctrl+p 查看上一条命令 上移光标  

ctrl+n 查看下一条命令 下移光标  



ctrl+a 移动光标至行首   

ctrl+e 移动光标至行尾  



ctrl+w 删除前一个词    

ctrl+u 删除从光标至行首的内容    

ctrl+k 删除从光标至行尾的内容   

ctrl+y 粘贴已删除的文本  

32. 文本编辑器  

vi vim Emacs  

33. 获取在线帮助  

man command  

不知道明确命令 通过关键字 -k  

man -k keyword  

按照章节  

1 用户命令  

2 系统调用  

3 unix高级编程库文档  

4 设备借口和设备驱动程序信息  

5 文件描述符  系统配置文件  

6 游戏  

7 文件格式 规范 编码  

8 系统命令和服务器 

34. info命令  

info  command  

35. shell输入和输出  

重定向  > 

command > file  将命令的执行结果输出到文件中  

如果文件不存在  shell会创建一个文件  

如果文件存在  shell会先清空文件  

如果不想把源文件覆盖 使用 >> 会将命令的输出结果加入到文件尾  

管道符 | 将一个命令执行结果输出到另一个命令  

重定向标准错误输出  2>  

>& 将标准输出和标准错误输出重定向到同一个地方  

36. 标准输入重定向  

```
head < file 

将file输入head命令 

```

37. 理解错误信息  

常见错误  

* 文件、目录错误  

* 权限错误  

* 分段故障  总线错误  

38. 查看和操作进程  

进程是运行在内存中的程序  每个进程都有一个数字ID 叫进程ID  ProcessID pid  

ps 列出所有进程  

pid  进程号  

tty  进程所在的终端设备  

stat 进程状态  S 睡眠  R 运行  

time  进程到目前为止所用cpu时长   mm:ss   

cmd 命令名  command   

命令选项  

ps  x  显示当前用户运行的所有进程  

ps  ax 显示系统当前运行的所有进程 包括其他用户的进程  

ps  u  显示更详细进程信息  

ps  w  显示命令的全名  而非仅显示一行以内的内容  

所以 ps aux  

ps u $$   $$ 表示当前的shell进程  

终止进程  用kill命令向进程发送一个信号 信号是内核发给进程的一条消息  

kill pid   

信号很多 默认是TERM terminate 

kill -stop pid 让进程暂停  

kill -cont pid 被暂停的进程仍然驻留在内存  等待被继续执行 使用cont信号可以继续执行进程  

kill是终止进程最粗鲁的方式  kill会强行终止进程  并将其移除内存  不会给进程清理和收尾的机会  

可以使用数字来代替信号名 kill -9  === kill -KILL 因为内核使用数字来代替   

39. 任务控制  Job control

通过不同的按键和命令想发送TSTP(类似STOP)和CONT信号的一种方式  

例如 使用CTRL+Z发送TSTP信号来暂停进程  然后输入fg 将进程置于前台  或 bg 进程移入后台继续运行进程   

jobs 查看暂停了那些进程


* 后台进程 

可以使用 & 将进程设置为后台运行  


40. 文件模式和权限  

读  写   运行   

ls -l  查看权限  

用户权限   用户组权限  其他用户 

\- 代表常规文件

d 代表目录

权限信息:  

r 可读  4

w 可写  2

x 运行  1

\- 无  

有些可执行文件的执行位是s 而不是x 表示你将以拥有者的身份运行该文件 而不是你自己的身份  

* 更改权限   

chmod g+r file  给用户组加可读权限  

chmod o+r file  给其他用户家可读权限  

也可以 chmod go+r 给用户组和其他用户添加可读权限   

chmod go+r 给用户组和其他用户取消K可读权限   

41. 符号链接 

符号链接是指向文件或者目录的文件  

符号链接相当于文件别名 或者windows中快捷方式  

符号链接的文件类型是l  

* 创建符号链接  

ln -s target linkname  

-s 表示是一个符号链接

如果没有 -s选项 ln命令会创建一个硬链接 为文件创建一个新的名字 新文件拥有老文件的所有状态信息  

和符号链接一样 打开这个新文件会直接打开文件内容  

42. 归档和压缩文件  

gzip 命令 只能压缩一个文件  生成一个后缀名gz的文件

gunzip 解压缩gz文件  

tar 压缩多个文件  生成后缀名tar 

tar cvf archive.tar file1 file2 ...

c 代表创建文件  

v 显示详细的命令执行消息  

f 代表文件 后面需要指定一个归档文件名  如果不指定归档文件名 则归档到磁带设备 如果文件名为- 则是归档到标准输入或输出  


解压缩tar文件  

tar xvf archive.tar

x 代表解压缩模式  

内容预览模式

tar t archive.tar  


压缩归档文件 .tar.gz

gunzip  file.tar.gz

tar xvf file.tar  

=== tar ztvf  file.tar.gz

=== zcat file.tar.gz | tar xvf - 

.tgz  === .tar.gz  .tgz是针对MS-DOS的FAT文件系统  


压缩命令 bzip2 生成后缀名为 .bz2文件  

该命令执行效率比gzip稍慢 主要用来压缩文本文件 因而在压缩源代码文件时候比较常用  

相应的解压缩命令 bunzip2  



43. Linux目录结构基础  

* bin

存放的是可执行文件  大部分基础Unix命令 如ls cp  

该目录中的大部分是c编译器创建的二进制文件 还有一些现代系统的shell文件  

* sbin

可执行的系统文件 这些可执行文件用来管理系统 普通用户一般不需要使用  

许多命令只有由root用户运行  

------------

* dev

* etc

* usr

* home

* lib

* tmp

* var

1. usr/

* bin

* sbin

* man

* lib

* local

* share

2. var/

* log

* tmp












 







 









